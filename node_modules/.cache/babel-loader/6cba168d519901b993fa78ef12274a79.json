{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n/* global window */\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\n\n\nvar _error = require(\"./error\");\n\nvar _error2 = _interopRequireDefault(_error);\n\nvar _extend = require(\"extend\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _jsBase = require(\"js-base64\");\n\nvar _request = require(\"./node/request\");\n\nvar _source = require(\"./node/source\");\n\nvar _storage = require(\"./node/storage\");\n\nvar _fingerprint = require(\"./node/fingerprint\");\n\nvar _fingerprint2 = _interopRequireDefault(_fingerprint);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defaultOptions = {\n  endpoint: null,\n  fingerprint: _fingerprint2.default,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  overridePatchMethod: false,\n  retryDelays: null,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  urlStorage: null,\n  fileReader: null,\n  uploadDataDuringCreation: false\n};\n\nvar Upload = function () {\n  function Upload(file, options) {\n    _classCallCheck(this, Upload);\n\n    this.options = (0, _extend2.default)(true, {}, defaultOptions, options); // The storage module used to store URLs\n\n    this._storage = this.options.urlStorage; // The underlying File/Blob object\n\n    this.file = file; // The URL against which the file will be uploaded\n\n    this.url = null; // The underlying XHR object for the current PATCH request\n\n    this._xhr = null; // The fingerpinrt for the current file (set after start())\n\n    this._fingerprint = null; // The offset used in the current PATCH request\n\n    this._offset = null; // True if the current PATCH request has been aborted\n\n    this._aborted = false; // The file's size in bytes\n\n    this._size = null; // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n\n    this._source = null; // The current count of attempts which have been made. Null indicates none.\n\n    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry\n\n    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.\n\n    this._offsetBeforeRetry = 0;\n  }\n\n  _createClass(Upload, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error(\"tus: neither an endpoint or an upload URL is provided\"));\n\n        return;\n      }\n\n      if (this.options.resume && this._storage == null) {\n        this._storage = (0, _storage.getStorage)();\n      }\n\n      if (this._source) {\n        this._start(this._source);\n      } else {\n        var fileReader = this.options.fileReader || _source.getSource;\n        fileReader(file, this.options.chunkSize, function (err, source) {\n          if (err) {\n            _this._emitError(err);\n\n            return;\n          }\n\n          _this._source = source;\n\n          _this._start(source);\n        });\n      }\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(source) {\n      var _this2 = this;\n\n      var file = this.file; // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n\n        if (isNaN(this._size)) {\n          this._emitError(new Error(\"tus: cannot convert `uploadSize` option into a number\"));\n\n          return;\n        }\n      } else {\n        this._size = source.size;\n\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\"));\n\n          return;\n        }\n      }\n\n      var retryDelays = this.options.retryDelays;\n\n      if (retryDelays != null) {\n        if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n          this._emitError(new Error(\"tus: the `retryDelays` option must either be an array or null\"));\n\n          return;\n        } else {\n          var errorCallback = this.options.onError;\n\n          this.options.onError = function (err) {\n            // Restore the original error callback which may have been set.\n            _this2.options.onError = errorCallback; // We will reset the attempt counter if\n            // - we were already able to connect to the server (offset != null) and\n            // - we were able to upload a small chunk of data to the server\n\n            var shouldResetDelays = _this2._offset != null && _this2._offset > _this2._offsetBeforeRetry;\n\n            if (shouldResetDelays) {\n              _this2._retryAttempt = 0;\n            }\n\n            var isOnline = true;\n\n            if (typeof window !== \"undefined\" && \"navigator\" in window && window.navigator.onLine === false) {\n              isOnline = false;\n            } // We only attempt a retry if\n            // - we didn't exceed the maxium number of retries, yet, and\n            // - this error was caused by a request or it's response and\n            // - the error is server error (i.e. no a status 4xx or a 409 or 423) and\n            // - the browser does not indicate that we are offline\n\n\n            var status = err.originalRequest ? err.originalRequest.status : 0;\n            var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;\n            var shouldRetry = _this2._retryAttempt < retryDelays.length && err.originalRequest != null && isServerError && isOnline;\n\n            if (!shouldRetry) {\n              _this2._emitError(err);\n\n              return;\n            }\n\n            var delay = retryDelays[_this2._retryAttempt++];\n            _this2._offsetBeforeRetry = _this2._offset;\n            _this2.options.uploadUrl = _this2.url;\n            _this2._retryTimeout = setTimeout(function () {\n              _this2.start();\n            }, delay);\n          };\n        }\n      } // Reset the aborted flag when the upload is started or else the\n      // _startUpload will stop before sending a request if the upload has been\n      // aborted previously.\n\n\n      this._aborted = false; // The upload had been started previously and we should reuse this URL.\n\n      if (this.url != null) {\n        this._resumeUpload();\n\n        return;\n      } // A URL has manually been specified, so we try to resume\n\n\n      if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n\n        this._resumeUpload();\n\n        return;\n      } // Try to find the endpoint for the file in the storage\n\n\n      if (this._hasStorage()) {\n        this.options.fingerprint(file, this.options, function (err, fingerprintValue) {\n          if (err) {\n            _this2._emitError(err);\n\n            return;\n          }\n\n          _this2._fingerprint = fingerprintValue;\n\n          _this2._storage.getItem(_this2._fingerprint, function (err, resumedUrl) {\n            if (err) {\n              _this2._emitError(err);\n\n              return;\n            }\n\n            if (resumedUrl != null) {\n              _this2.url = resumedUrl;\n\n              _this2._resumeUpload();\n            } else {\n              _this2._createUpload();\n            }\n          });\n        });\n      } else {\n        // An upload has not started for the file yet, so we start a new one\n        this._createUpload();\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate, cb) {\n      var _this3 = this;\n\n      if (this._xhr !== null) {\n        this._xhr.abort();\n\n        this._source.close();\n      }\n\n      this._aborted = true;\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      cb = cb || function () {};\n\n      if (shouldTerminate) {\n        Upload.terminate(this.url, this.options, function (err, xhr) {\n          if (err) {\n            return cb(err, xhr);\n          }\n\n          _this3._hasStorage() ? _this3._storage.removeItem(_this3._fingerprint, cb) : cb();\n        });\n      } else {\n        cb();\n      }\n    }\n  }, {\n    key: \"_hasStorage\",\n    value: function _hasStorage() {\n      return this.options.resume && this._storage;\n    }\n  }, {\n    key: \"_emitXhrError\",\n    value: function _emitXhrError(xhr, err, causingErr) {\n      this._emitError(new _error2.default(err, causingErr, xhr));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      if (typeof this.options.onError === \"function\") {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (typeof this.options.onSuccess === \"function\") {\n        this.options.onSuccess();\n      }\n    }\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     * @param  {number} bytesSent  Number of bytes sent to the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === \"function\") {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param  {number} chunkSize  Size of the chunk that was accepted by the\n     *                             server.\n     * @param  {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === \"function\") {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n    /**\n     * Set the headers used in the request and the withCredentials property\n     * as defined in the options\n     *\n     * @param {XMLHttpRequest} xhr\n     */\n\n  }, {\n    key: \"_setupXHR\",\n    value: function _setupXHR(xhr) {\n      this._xhr = xhr;\n      setupXHR(xhr, this.options);\n    }\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this4 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error(\"tus: unable to create upload because no endpoint is provided\"));\n\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"POST\", this.options.endpoint, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this4._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n\n          return;\n        }\n\n        var location = xhr.getResponseHeader(\"Location\");\n\n        if (location == null) {\n          _this4._emitXhrError(xhr, new Error(\"tus: invalid or missing Location header\"));\n\n          return;\n        }\n\n        _this4.url = (0, _request.resolveUrl)(_this4.options.endpoint, location);\n\n        if (_this4._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this4._emitSuccess();\n\n          _this4._source.close();\n\n          return;\n        }\n\n        if (_this4._hasStorage()) {\n          _this4._storage.setItem(_this4._fingerprint, _this4.url, function (err) {\n            if (err) {\n              _this4._emitError(err);\n            }\n          });\n        }\n\n        if (_this4.options.uploadDataDuringCreation) {\n          _this4._handleUploadResponse(xhr);\n        } else {\n          _this4._offset = 0;\n\n          _this4._startUpload();\n        }\n      };\n\n      xhr.onerror = function (err) {\n        _this4._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n\n      if (this.options.uploadLengthDeferred) {\n        xhr.setRequestHeader(\"Upload-Defer-Length\", 1);\n      } else {\n        xhr.setRequestHeader(\"Upload-Length\", this._size);\n      } // Add metadata if values have been added\n\n\n      var metadata = encodeMetadata(this.options.metadata);\n\n      if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n      }\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n\n        this._addChunkToRequest(xhr);\n      } else {\n        xhr.send(null);\n      }\n    }\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this5 = this;\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"HEAD\", this.url, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          if (_this5._hasStorage() && inStatusCategory(xhr.status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this5._storage.removeItem(_this5._fingerprint, function (err) {\n              if (err) {\n                _this5._emitError(err);\n              }\n            });\n          } // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n\n\n          if (xhr.status === 423) {\n            _this5._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n\n            return;\n          }\n\n          if (!_this5.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this5._emitXhrError(xhr, new Error(\"tus: unable to resume upload (new upload cannot be created without an endpoint)\"));\n\n            return;\n          } // Try to create a new upload\n\n\n          _this5.url = null;\n\n          _this5._createUpload();\n\n          return;\n        }\n\n        var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n\n        if (isNaN(offset)) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n\n          return;\n        }\n\n        var length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n\n        if (isNaN(length) && !_this5.options.uploadLengthDeferred) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n\n          return;\n        } // Upload has already been completed and we do not need to send additional\n        // data to the server\n\n\n        if (offset === length) {\n          _this5._emitProgress(length, length);\n\n          _this5._emitSuccess();\n\n          return;\n        }\n\n        _this5._offset = offset;\n\n        _this5._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        _this5._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n\n      xhr.send(null);\n    }\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startUpload\",\n    value: function _startUpload() {\n      var _this6 = this; // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n\n\n      if (this._aborted) {\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)(); // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n\n      if (this.options.overridePatchMethod) {\n        xhr.open(\"POST\", this.url, true);\n        xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n      } else {\n        xhr.open(\"PATCH\", this.url, true);\n      }\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this6._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n\n          return;\n        }\n\n        _this6._handleUploadResponse(xhr);\n      };\n\n      xhr.onerror = function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this6._aborted) {\n          return;\n        }\n\n        _this6._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + _this6._offset), err);\n      };\n\n      this._setupXHR(xhr);\n\n      xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n\n      this._addChunkToRequest(xhr);\n    }\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied XHR object. It will not handle the response.\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(xhr) {\n      var _this7 = this; // Test support for progress events before attaching an event listener\n\n\n      if (\"upload\" in xhr) {\n        xhr.upload.onprogress = function (e) {\n          if (!e.lengthComputable) {\n            return;\n          }\n\n          _this7._emitProgress(start + e.loaded, _this7._size);\n        };\n      }\n\n      xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize; // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      this._source.slice(start, end, function (err, value, complete) {\n        if (err) {\n          _this7._emitError(err);\n\n          return;\n        }\n\n        if (_this7.options.uploadLengthDeferred) {\n          if (complete) {\n            _this7._size = _this7._offset + (value && value.size ? value.size : 0);\n            xhr.setRequestHeader(\"Upload-Length\", _this7._size);\n          }\n        }\n\n        if (value === null) {\n          xhr.send();\n        } else {\n          xhr.send(value);\n\n          _this7._emitProgress(_this7._offset, _this7._size);\n        }\n      });\n    }\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(xhr) {\n      var _this8 = this;\n\n      var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        if (this.options.removeFingerprintOnSuccess && this.options.resume) {\n          // Remove stored fingerprint and corresponding endpoint. This causes\n          // new upload of the same file must be treated as a different file.\n          this._storage.removeItem(this._fingerprint, function (err) {\n            if (err) {\n              _this8._emitError(err);\n            }\n          });\n        } // Yay, finally done :)\n\n\n        this._emitSuccess();\n\n        this._source.close();\n\n        return;\n      }\n\n      this._startUpload();\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options, cb) {\n      if (typeof options !== \"function\" && typeof cb !== \"function\") {\n        throw new Error(\"tus: a callback function must be specified\");\n      }\n\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"DELETE\", url, true);\n\n      xhr.onload = function () {\n        if (xhr.status !== 204) {\n          cb(new _error2.default(new Error(\"tus: unexpected response while terminating upload\"), null, xhr));\n          return;\n        }\n\n        cb();\n      };\n\n      xhr.onerror = function (err) {\n        cb(new _error2.default(err, new Error(\"tus: failed to terminate upload\"), xhr));\n      };\n\n      setupXHR(xhr, options);\n      xhr.send(null);\n    }\n  }]);\n\n  return Upload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(key + \" \" + _jsBase.Base64.encode(metadata[key]));\n  }\n\n  return encoded.join(\",\");\n}\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\n\n\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n\nfunction setupXHR(xhr, options) {\n  xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    xhr.setRequestHeader(name, headers[name]);\n  }\n\n  xhr.withCredentials = options.withCredentials;\n}\n\nUpload.defaultOptions = defaultOptions;\nexports.default = Upload;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_error","require","_error2","_interopRequireDefault","_extend","_extend2","_jsBase","_request","_source","_storage","_fingerprint","_fingerprint2","obj","__esModule","default","_classCallCheck","instance","TypeError","defaultOptions","endpoint","fingerprint","resume","onProgress","onChunkComplete","onSuccess","onError","headers","chunkSize","Infinity","withCredentials","uploadUrl","uploadSize","overridePatchMethod","retryDelays","removeFingerprintOnSuccess","uploadLengthDeferred","urlStorage","fileReader","uploadDataDuringCreation","Upload","file","options","url","_xhr","_offset","_aborted","_size","_retryAttempt","_retryTimeout","_offsetBeforeRetry","start","_this","_emitError","Error","getStorage","_start","getSource","err","source","_this2","isNaN","size","toString","call","errorCallback","shouldResetDelays","isOnline","window","navigator","onLine","status","originalRequest","isServerError","inStatusCategory","shouldRetry","delay","setTimeout","_resumeUpload","_hasStorage","fingerprintValue","getItem","resumedUrl","_createUpload","abort","shouldTerminate","cb","_this3","close","clearTimeout","terminate","xhr","removeItem","_emitXhrError","causingErr","_emitSuccess","_emitProgress","bytesSent","bytesTotal","_emitChunkComplete","bytesAccepted","_setupXHR","setupXHR","_this4","newRequest","open","onload","location","getResponseHeader","resolveUrl","setItem","_handleUploadResponse","_startUpload","onerror","setRequestHeader","metadata","encodeMetadata","_addChunkToRequest","send","_this5","offset","parseInt","_this6","_this7","upload","onprogress","e","lengthComputable","loaded","end","slice","complete","_this8","encoded","push","Base64","encode","join","category","name"],"sources":["/home/gapasil/Рабочий стол/Загрузки/дз/javascript/netlear/clientNetlear/node_modules/tus-js-client/lib.es5/upload.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window */\n\n\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\n\n\nvar _error = require(\"./error\");\n\nvar _error2 = _interopRequireDefault(_error);\n\nvar _extend = require(\"extend\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _jsBase = require(\"js-base64\");\n\nvar _request = require(\"./node/request\");\n\nvar _source = require(\"./node/source\");\n\nvar _storage = require(\"./node/storage\");\n\nvar _fingerprint = require(\"./node/fingerprint\");\n\nvar _fingerprint2 = _interopRequireDefault(_fingerprint);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaultOptions = {\n  endpoint: null,\n  fingerprint: _fingerprint2.default,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  overridePatchMethod: false,\n  retryDelays: null,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  urlStorage: null,\n  fileReader: null,\n  uploadDataDuringCreation: false\n};\n\nvar Upload = function () {\n  function Upload(file, options) {\n    _classCallCheck(this, Upload);\n\n    this.options = (0, _extend2.default)(true, {}, defaultOptions, options);\n\n    // The storage module used to store URLs\n    this._storage = this.options.urlStorage;\n\n    // The underlying File/Blob object\n    this.file = file;\n\n    // The URL against which the file will be uploaded\n    this.url = null;\n\n    // The underlying XHR object for the current PATCH request\n    this._xhr = null;\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null;\n\n    // The offset used in the current PATCH request\n    this._offset = null;\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false;\n\n    // The file's size in bytes\n    this._size = null;\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null;\n\n    // The current count of attempts which have been made. Null indicates none.\n    this._retryAttempt = 0;\n\n    // The timeout's ID which is used to delay the next retry\n    this._retryTimeout = null;\n\n    // The offset of the remote upload before the latest attempt was started.\n    this._offsetBeforeRetry = 0;\n  }\n\n  _createClass(Upload, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error(\"tus: neither an endpoint or an upload URL is provided\"));\n        return;\n      }\n\n      if (this.options.resume && this._storage == null) {\n        this._storage = (0, _storage.getStorage)();\n      }\n\n      if (this._source) {\n        this._start(this._source);\n      } else {\n        var fileReader = this.options.fileReader || _source.getSource;\n        fileReader(file, this.options.chunkSize, function (err, source) {\n          if (err) {\n            _this._emitError(err);\n            return;\n          }\n\n          _this._source = source;\n          _this._start(source);\n        });\n      }\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(source) {\n      var _this2 = this;\n\n      var file = this.file;\n\n      // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n        if (isNaN(this._size)) {\n          this._emitError(new Error(\"tus: cannot convert `uploadSize` option into a number\"));\n          return;\n        }\n      } else {\n        this._size = source.size;\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\"));\n          return;\n        }\n      }\n\n      var retryDelays = this.options.retryDelays;\n      if (retryDelays != null) {\n        if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n          this._emitError(new Error(\"tus: the `retryDelays` option must either be an array or null\"));\n          return;\n        } else {\n          var errorCallback = this.options.onError;\n          this.options.onError = function (err) {\n            // Restore the original error callback which may have been set.\n            _this2.options.onError = errorCallback;\n\n            // We will reset the attempt counter if\n            // - we were already able to connect to the server (offset != null) and\n            // - we were able to upload a small chunk of data to the server\n            var shouldResetDelays = _this2._offset != null && _this2._offset > _this2._offsetBeforeRetry;\n            if (shouldResetDelays) {\n              _this2._retryAttempt = 0;\n            }\n\n            var isOnline = true;\n            if (typeof window !== \"undefined\" && \"navigator\" in window && window.navigator.onLine === false) {\n              isOnline = false;\n            }\n\n            // We only attempt a retry if\n            // - we didn't exceed the maxium number of retries, yet, and\n            // - this error was caused by a request or it's response and\n            // - the error is server error (i.e. no a status 4xx or a 409 or 423) and\n            // - the browser does not indicate that we are offline\n            var status = err.originalRequest ? err.originalRequest.status : 0;\n            var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;\n            var shouldRetry = _this2._retryAttempt < retryDelays.length && err.originalRequest != null && isServerError && isOnline;\n\n            if (!shouldRetry) {\n              _this2._emitError(err);\n              return;\n            }\n\n            var delay = retryDelays[_this2._retryAttempt++];\n\n            _this2._offsetBeforeRetry = _this2._offset;\n            _this2.options.uploadUrl = _this2.url;\n\n            _this2._retryTimeout = setTimeout(function () {\n              _this2.start();\n            }, delay);\n          };\n        }\n      }\n\n      // Reset the aborted flag when the upload is started or else the\n      // _startUpload will stop before sending a request if the upload has been\n      // aborted previously.\n      this._aborted = false;\n\n      // The upload had been started previously and we should reuse this URL.\n      if (this.url != null) {\n        this._resumeUpload();\n        return;\n      }\n\n      // A URL has manually been specified, so we try to resume\n      if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n        this._resumeUpload();\n        return;\n      }\n\n      // Try to find the endpoint for the file in the storage\n      if (this._hasStorage()) {\n        this.options.fingerprint(file, this.options, function (err, fingerprintValue) {\n          if (err) {\n            _this2._emitError(err);\n            return;\n          }\n\n          _this2._fingerprint = fingerprintValue;\n          _this2._storage.getItem(_this2._fingerprint, function (err, resumedUrl) {\n            if (err) {\n              _this2._emitError(err);\n              return;\n            }\n\n            if (resumedUrl != null) {\n              _this2.url = resumedUrl;\n              _this2._resumeUpload();\n            } else {\n              _this2._createUpload();\n            }\n          });\n        });\n      } else {\n        // An upload has not started for the file yet, so we start a new one\n        this._createUpload();\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate, cb) {\n      var _this3 = this;\n\n      if (this._xhr !== null) {\n        this._xhr.abort();\n        this._source.close();\n      }\n      this._aborted = true;\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      cb = cb || function () {};\n      if (shouldTerminate) {\n        Upload.terminate(this.url, this.options, function (err, xhr) {\n          if (err) {\n            return cb(err, xhr);\n          }\n\n          _this3._hasStorage() ? _this3._storage.removeItem(_this3._fingerprint, cb) : cb();\n        });\n      } else {\n        cb();\n      }\n    }\n  }, {\n    key: \"_hasStorage\",\n    value: function _hasStorage() {\n      return this.options.resume && this._storage;\n    }\n  }, {\n    key: \"_emitXhrError\",\n    value: function _emitXhrError(xhr, err, causingErr) {\n      this._emitError(new _error2.default(err, causingErr, xhr));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      if (typeof this.options.onError === \"function\") {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (typeof this.options.onSuccess === \"function\") {\n        this.options.onSuccess();\n      }\n    }\n\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     * @param  {number} bytesSent  Number of bytes sent to the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === \"function\") {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param  {number} chunkSize  Size of the chunk that was accepted by the\n     *                             server.\n     * @param  {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === \"function\") {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n\n    /**\n     * Set the headers used in the request and the withCredentials property\n     * as defined in the options\n     *\n     * @param {XMLHttpRequest} xhr\n     */\n\n  }, {\n    key: \"_setupXHR\",\n    value: function _setupXHR(xhr) {\n      this._xhr = xhr;\n      setupXHR(xhr, this.options);\n    }\n\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this4 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error(\"tus: unable to create upload because no endpoint is provided\"));\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"POST\", this.options.endpoint, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this4._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n          return;\n        }\n\n        var location = xhr.getResponseHeader(\"Location\");\n        if (location == null) {\n          _this4._emitXhrError(xhr, new Error(\"tus: invalid or missing Location header\"));\n          return;\n        }\n\n        _this4.url = (0, _request.resolveUrl)(_this4.options.endpoint, location);\n\n        if (_this4._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this4._emitSuccess();\n          _this4._source.close();\n          return;\n        }\n\n        if (_this4._hasStorage()) {\n          _this4._storage.setItem(_this4._fingerprint, _this4.url, function (err) {\n            if (err) {\n              _this4._emitError(err);\n            }\n          });\n        }\n\n        if (_this4.options.uploadDataDuringCreation) {\n          _this4._handleUploadResponse(xhr);\n        } else {\n          _this4._offset = 0;\n          _this4._startUpload();\n        }\n      };\n\n      xhr.onerror = function (err) {\n        _this4._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n      if (this.options.uploadLengthDeferred) {\n        xhr.setRequestHeader(\"Upload-Defer-Length\", 1);\n      } else {\n        xhr.setRequestHeader(\"Upload-Length\", this._size);\n      }\n\n      // Add metadata if values have been added\n      var metadata = encodeMetadata(this.options.metadata);\n      if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n      }\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n        this._addChunkToRequest(xhr);\n      } else {\n        xhr.send(null);\n      }\n    }\n\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this5 = this;\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"HEAD\", this.url, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          if (_this5._hasStorage() && inStatusCategory(xhr.status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this5._storage.removeItem(_this5._fingerprint, function (err) {\n              if (err) {\n                _this5._emitError(err);\n              }\n            });\n          }\n\n          // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n          if (xhr.status === 423) {\n            _this5._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n            return;\n          }\n\n          if (!_this5.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this5._emitXhrError(xhr, new Error(\"tus: unable to resume upload (new upload cannot be created without an endpoint)\"));\n            return;\n          }\n\n          // Try to create a new upload\n          _this5.url = null;\n          _this5._createUpload();\n          return;\n        }\n\n        var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n        if (isNaN(offset)) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n          return;\n        }\n\n        var length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n        if (isNaN(length) && !_this5.options.uploadLengthDeferred) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n          return;\n        }\n\n        // Upload has already been completed and we do not need to send additional\n        // data to the server\n        if (offset === length) {\n          _this5._emitProgress(length, length);\n          _this5._emitSuccess();\n          return;\n        }\n\n        _this5._offset = offset;\n        _this5._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        _this5._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n      xhr.send(null);\n    }\n\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startUpload\",\n    value: function _startUpload() {\n      var _this6 = this;\n\n      // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n      if (this._aborted) {\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n\n      // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n      if (this.options.overridePatchMethod) {\n        xhr.open(\"POST\", this.url, true);\n        xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n      } else {\n        xhr.open(\"PATCH\", this.url, true);\n      }\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this6._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n          return;\n        }\n\n        _this6._handleUploadResponse(xhr);\n      };\n\n      xhr.onerror = function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this6._aborted) {\n          return;\n        }\n\n        _this6._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + _this6._offset), err);\n      };\n\n      this._setupXHR(xhr);\n\n      xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n      this._addChunkToRequest(xhr);\n    }\n\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied XHR object. It will not handle the response.\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(xhr) {\n      var _this7 = this;\n\n      // Test support for progress events before attaching an event listener\n      if (\"upload\" in xhr) {\n        xhr.upload.onprogress = function (e) {\n          if (!e.lengthComputable) {\n            return;\n          }\n\n          _this7._emitProgress(start + e.loaded, _this7._size);\n        };\n      }\n\n      xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n\n      // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      this._source.slice(start, end, function (err, value, complete) {\n        if (err) {\n          _this7._emitError(err);\n          return;\n        }\n\n        if (_this7.options.uploadLengthDeferred) {\n          if (complete) {\n            _this7._size = _this7._offset + (value && value.size ? value.size : 0);\n            xhr.setRequestHeader(\"Upload-Length\", _this7._size);\n          }\n        }\n\n        if (value === null) {\n          xhr.send();\n        } else {\n          xhr.send(value);\n          _this7._emitProgress(_this7._offset, _this7._size);\n        }\n      });\n    }\n\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(xhr) {\n      var _this8 = this;\n\n      var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        if (this.options.removeFingerprintOnSuccess && this.options.resume) {\n          // Remove stored fingerprint and corresponding endpoint. This causes\n          // new upload of the same file must be treated as a different file.\n          this._storage.removeItem(this._fingerprint, function (err) {\n            if (err) {\n              _this8._emitError(err);\n            }\n          });\n        }\n\n        // Yay, finally done :)\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n\n      this._startUpload();\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options, cb) {\n      if (typeof options !== \"function\" && typeof cb !== \"function\") {\n        throw new Error(\"tus: a callback function must be specified\");\n      }\n\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"DELETE\", url, true);\n\n      xhr.onload = function () {\n        if (xhr.status !== 204) {\n          cb(new _error2.default(new Error(\"tus: unexpected response while terminating upload\"), null, xhr));\n          return;\n        }\n\n        cb();\n      };\n\n      xhr.onerror = function (err) {\n        cb(new _error2.default(err, new Error(\"tus: failed to terminate upload\"), xhr));\n      };\n\n      setupXHR(xhr, options);\n      xhr.send(null);\n    }\n  }]);\n\n  return Upload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(key + \" \" + _jsBase.Base64.encode(metadata[key]));\n  }\n\n  return encoded.join(\",\");\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n\nfunction setupXHR(xhr, options) {\n  xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    xhr.setRequestHeader(name, headers[name]);\n  }\n\n  xhr.withCredentials = options.withCredentials;\n}\n\nUpload.defaultOptions = defaultOptions;\n\nexports.default = Upload;"],"mappings":"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"},"metadata":{},"sourceType":"script"}